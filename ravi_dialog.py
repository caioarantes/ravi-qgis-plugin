# -*- coding: utf-8 -*-
"""
/***************************************************************************
 RAVIDialog
                                 A QGIS plugin
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2024-10-24
        git sha              : $Format:%H$
        copyright            : (C) 2024 by Caio Arantes
        email                : github.com/caioarantes
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os
import sys
import importlib
import platform
import zipfile
import json
import webbrowser
import io
import array
from datetime import datetime, timedelta
from dateutil.relativedelta import relativedelta

# PyQt5 and QGIS imports
from PyQt5.QtCore import QDate, Qt, QVariant
from PyQt5.QtWidgets import (
    QApplication, QMainWindow, QLabel, QMessageBox, QFileDialog, QGridLayout, 
    QWidget, QDesktopWidget, QDialog, QVBoxLayout, QCheckBox, QDialogButtonBox, 
    QDateEdit, QScrollArea, QPushButton, QHBoxLayout, QToolButton
)
from qgis.PyQt import uic, QtWidgets
from qgis.core import (
    QgsProject, QgsRasterLayer, QgsRasterShader, QgsColorRampShader, 
    QgsSingleBandPseudoColorRenderer, QgsStyle, QgsRasterBandStats, 
    QgsMapLayer, QgsVectorLayer, QgsColorRamp, QgsLayerTreeLayer, 
    QgsCoordinateReferenceSystem, QgsCoordinateTransform, 
    QgsMultiBandColorRenderer, QgsContrastEnhancement, 
    QgsProcessingFeedback, QgsApplication, QgsRectangle, 
    QgsFeature, QgsGeometry, QgsField, QgsVectorFileWriter
)
from qgis.utils import iface
import qgis

# Scientific and data processing libraries
import pandas as pd
import numpy as np
from scipy.signal import savgol_filter
import geopandas as gpd
import requests

# Plotly imports for visualization
import plotly.express as px
import plotly.graph_objects as go
from plotly.subplots import make_subplots

# Processing module for QGIS
import processing

# Earth Engine installation and import
def install_earthengine_api():
    try:
        import pip
        pip_args = ['install', 'earthengine-api==1.3.1']
        pip.main(pip_args)
        print("Earth Engine API installed successfully.")
    except AttributeError:
        from pip._internal.cli.main import main as pip_main
        pip_main(['install', 'earthengine-api==1.3.1'])
        print("Earth Engine API installed successfully.")
    except Exception as e:
        print(f"An error occurred during installation: {e}")

# Check if the Earth Engine API is already installed
try:
    importlib.import_module('ee')
    print("Earth Engine API is already installed.")
    import ee
except ImportError:
    print("Earth Engine API not found. Installing...")
    install_earthengine_api()
    try:
        importlib.import_module('ee')
        print("Earth Engine API imported successfully.")
        import ee
    except ImportError:
        print("Earth Engine API could not be imported after installation.")


# This loads your .ui file so that PyQt can populate your plugin with the elements from Qt Designer
FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'ravi_dialog_base.ui'))


class RAVIDialog(QtWidgets.QDialog, FORM_CLASS):

    def __init__(self, parent=None):
        """Constructor."""
        super(RAVIDialog, self).__init__(parent)
        
        self.setWindowFlags(Qt.Window | Qt.WindowMinimizeButtonHint)
        super().__init__(None, Qt.WindowStaysOnTopHint | Qt.WindowMinimizeButtonHint | Qt.WindowCloseButtonHint)

        # #widgets-and-dialogs-with-auto-connect
        self.setupUi(self)  

        self.resizeEvent('pequeno')  # What does this do? Explain the purpose of this line
        self.tabWidget.setCurrentIndex(0)

        # Connect signals and slots
        self.autenticacao.clicked.connect(self.auth)
        self.desautenticacao.clicked.connect(self.auth_clear)
        self.update_vector.clicked.connect(self.load_vector_layers)
        self.tabWidget.currentChanged.connect(self.on_tab_changed)
        self.load_1index.clicked.connect(self.first_index)
        self.load_1rgb.clicked.connect(self.first_rgb)
        self.composicao.clicked.connect(self.composicao_clicked)
        self.clear_raster.clicked.connect(self.clear_all_raster_layers)
        self.hybrid.clicked.connect(self.hybrid_function)
        self.pushButtonNext.clicked.connect(self.next_clicked)
        self.QPushButton_back.clicked.connect(self.back_clicked)
        self.loadtimeseries.clicked.connect(self.loadtimeseries_clicked)
        self.navegador.clicked.connect(self.open_browser)
        self.datasrecorte.clicked.connect(self.datasrecorte_clicked)
        self.salvar.clicked.connect(self.salvar_clicked)
        self.build_vector_layer.clicked.connect(self.build_vector_layer_clicked)
        self.apply_filter.clicked.connect(self.apply_filter_clicked)
        self.filtro1.stateChanged.connect(self.plot_timeseries)
        self.filtro_grau.currentIndexChanged.connect(self.plot_timeseries)
        self.window_len.currentIndexChanged.connect(self.plot_timeseries)
        self.vector_layer_combobox.currentIndexChanged.connect(self.get_selected_layer_path)
        self.mQgsFileWidget.fileChanged.connect(self.on_file_changed)  
        self.customfilter.clicked.connect(self.custom_filter_clicked)
        self.radioButton_year.clicked.connect(self.last_year_clicked)
        self.radioButton_3years.clicked.connect(self.last_3_years_clicked)
        self.radioButton_5years.clicked.connect(self.last_5_years_clicked)  
        self.radioButton_select_year.clicked.connect(self.selected_year_clicked)
        self.combo_year.currentIndexChanged.connect(self.selected_year_clicked)
        self.horizontalSlider.valueChanged.connect(self.update_labels)
        self.horizontalSlider_2.valueChanged.connect(self.update_labels)
        self.horizontalSlider_3.valueChanged.connect(self.update_labels)
        self.textEdit.setReadOnly(True)  # Prevent editing
        self.textEdit.setTextInteractionFlags(Qt.TextBrowserInteraction)
        self.nasapower.clicked.connect(self.open_nasapower)
        self.clear_nasa.clicked.connect(self.clear_nasa_clicked)
        self.textEdit.anchorClicked.connect(self.open_link)  
        

        # Set default dates
        self.last_year_clicked()

        self.autentication = False
        self.folder_set = False
        self.inicio = None
        self.final = None
        self.nuvem = None
        self.vector_path = None
        self.aoi = None
        self.aoi_ckecked = False
        self.df = None
        self.recorte_datas = None
        self.df_aux = None
        self.selected_dates = []
        self.output_folder = None
        self.df_nasa = None

    def clear_nasa_clicked(self):
        self.df_nasa = None
        self.plot_timeseries()

    def hybrid_function(self):
        existing_layers = QgsProject.instance().mapLayers().values()
        layer_names = [layer.name() for layer in existing_layers]
        if "Google Hybrid" in layer_names:
            self.pop_aviso("Google Hybrid layer already added.")
            return
        
        google_hybrid_url = "type=xyz&zmin=0&zmax=20&url=https://mt1.google.com/vt/lyrs%3Dy%26x%3D{x}%26y%3D{y}%26z%3D{z}"
        layer_name = "Google Hybrid"
        provider_type = "wms"

        try:
            # Create the XYZ tile layer
            google_hybrid_layer = QgsRasterLayer(google_hybrid_url, layer_name, provider_type)

            if google_hybrid_layer.isValid():
                # Add the layer to the project
                QgsProject.instance().addMapLayer(google_hybrid_layer, False)

                # Set the project CRS to EPSG:4326 (WGS 84)
                crs_4326 = QgsCoordinateReferenceSystem("EPSG:4326")
                QgsProject.instance().setCrs(crs_4326)

                # Adjust visibility and add to the layer tree
                google_hybrid_layer.setOpacity(1)
                root = QgsProject.instance().layerTreeRoot()
                root.addLayer(google_hybrid_layer)

                # Refresh the canvas and zoom to extent
                iface.mapCanvas().refresh()
                iface.mapCanvas().zoomToFullExtent()
                print(f"{layer_name} layer added successfully in EPSG:4326.")
            else:
                print(f"Failed to load {layer_name}. Invalid layer.")
        except Exception as e:
            print(f"Error loading {layer_name}: {e}")
        project = QgsProject.instance()
        project.setCrs(QgsCoordinateReferenceSystem("EPSG:4326"))

    def update_labels(self):
        self.customfilter.setText(f"Custom filter (At least {self.horizontalSlider.value()}% non-cloudy pixels within AOI)")
        self.label_coverage.setText(str(self.horizontalSlider_2.value()) + "%")
        self.label_cloud.setText(str(self.horizontalSlider_3.value()) + "%")

    def custom_filter_clicked(self):
        if self.customfilter.isChecked():
            self.horizontalSlider.setEnabled(True)
        else:
            self.horizontalSlider.setEnabled(False)

    def open_link(self, url):
        """Open the clicked link in the default web browser."""
        print(f"Opening URL: {url.toString()}")
        webbrowser.open(url.toString())

    def last_year_clicked(self):
        today = datetime.today().strftime('%Y-%m-%d')
        one_month_ago = (datetime.today() - relativedelta(months=12)).strftime('%Y-%m-%d')
        self.finaledit.setDate(QDate.fromString(today, 'yyyy-MM-dd'))
        self.incioedit.setDate(QDate.fromString(one_month_ago, 'yyyy-MM-dd'))

    def last_3_years_clicked(self):
        today = datetime.today().strftime('%Y-%m-%d')
        one_month_ago = (datetime.today() - relativedelta(months=36)).strftime('%Y-%m-%d')
        self.finaledit.setDate(QDate.fromString(today, 'yyyy-MM-dd'))
        self.incioedit.setDate(QDate.fromString(one_month_ago, 'yyyy-MM-dd'))

    def last_5_years_clicked(self):
        today = datetime.today().strftime('%Y-%m-%d')
        one_month_ago = (datetime.today() - relativedelta(months=60)).strftime('%Y-%m-%d')
        self.finaledit.setDate(QDate.fromString(today, 'yyyy-MM-dd'))
        self.incioedit.setDate(QDate.fromString(one_month_ago, 'yyyy-MM-dd'))

    def selected_year_clicked(self):
        year = self.combo_year.currentText()
        start = f"{year}-01-01"
        end = f"{year}-12-31"
        self.incioedit.setDate(QDate.fromString(start, 'yyyy-MM-dd'))
        self.finaledit.setDate(QDate.fromString(end, 'yyyy-MM-dd'))

    def build_vector_layer_clicked(self):

        project = QgsProject.instance()
        project.setCrs(QgsCoordinateReferenceSystem("EPSG:4326"))
        if self.output_folder is None:
            self.pop_aviso("Please select a output folder first.")
            return

        existing_layers = QgsProject.instance().mapLayers().values()
        layer_names = [layer.name() for layer in existing_layers]
        if "Google Hybrid" not in layer_names:
            self.pop_aviso("Please load the Google Hybrid layer first.")
            return


        # Get the extent of the current map canvas
        canvas = iface.mapCanvas()
        extent = canvas.extent()

        # Create a polygon (rectangle) representing the extent
        rect = QgsRectangle(extent)

        crs = "EPSG:4326"  # Use CRS 4326
        # Create a vector layer with the extent as a polygon
        layer = QgsVectorLayer(f"Polygon?crs={crs}", "canvas_extent", "memory")
        pr = layer.dataProvider()

        # Add fields (if necessary)
        pr.addAttributes([QgsField("id", QVariant.Int)])
        layer.updateFields()

        # Create a feature for the extent
        feature = QgsFeature()
        geometry = QgsGeometry.fromRect(rect)
        feature.setGeometry(geometry)
        feature.setAttributes([1])  # You can set any attribute value here
        pr.addFeature(feature)

        # Update layer and add it to the map
        layer.updateExtents()

        shp_path = self.get_unique_filename_shp("canvas_extent")
        print(f"Shapefile path: {shp_path}")
        shp_name = os.path.basename(shp_path).replace(".shp", "")
        print(f"Shapefile name: {shp_name}")

        QgsVectorFileWriter.writeAsVectorFormat(layer, shp_path, "UTF-8", layer.crs(), "ESRI Shapefile")

        # Load the shapefile into the canvas
        loaded_layer = QgsVectorLayer(shp_path, shp_name, "ogr")
        if loaded_layer.isValid():
            # Check if the CRS is EPSG:4326
            if loaded_layer.crs().authid() != "EPSG:4326":
                # Reproject the layer to EPSG:4326
                crs_4326 = QgsCoordinateReferenceSystem("EPSG:4326")
                loaded_layer = processing.run("qgis:reprojectlayer", {
                    'INPUT': loaded_layer,
                    'TARGET_CRS': crs_4326,
                    'OUTPUT': 'memory:'
                })['OUTPUT']
                loaded_layer.setCrs(crs_4326)
                print(f"Layer reprojected to EPSG:4326")

            QgsProject.instance().addMapLayer(loaded_layer)
            self.zoom_to_layer(shp_name)
            self.load_vector_layers()
            # iface.mapCanvas().setExtent(loaded_layer.extent())  # Optional: Set the canvas extent to the layer extent
        else:
            print("Failed to load the shapefile.")

    def salvar_clicked(self):    

        name = self.series_indice.currentText() + '_' + self.vector_layer_combobox.currentText() + '_time_series.csv'
        caminho,_ = QFileDialog.getSaveFileName(self,"Salvar",name,".csv (*.csv)")
        if caminho == '':
            return
        arquivo = open(caminho, 'w', encoding = 'latin')
        arquivo.write(self.df_aux.to_csv(decimal = '.', sep=',', index = False, encoding = "latin", lineterminator='\n'))
        arquivo.close()
        #os.startfile(caminho)

    def datasrecorte_clicked(self):
        dialog = QDialog(self)
        dialog.setWindowTitle("Date Selection for Time Series")
        dialog.setGeometry(100, 100, 400, 500)

        layout = QVBoxLayout(dialog)

        # Scroll Area for Checkboxes
        scroll_area = QScrollArea(dialog)
        scroll_area.setWidgetResizable(True)
        scroll_content = QWidget()
        scroll_layout = QVBoxLayout(scroll_content)

        self.checkboxes = []
        self.group_checkboxes = {}  # Store month group checkboxes
        self.year_checkboxes = {}  # Store year checkboxes
        self.group_widgets = {}  # Store month group content widgets

        # Group Dates by Year and Month
        self.df['date'] = pd.to_datetime(self.df['date'])  # Ensure dates are datetime objects
        grouped = self.df.groupby([self.df['date'].dt.year, self.df['date'].dt.month])

        # Organize by Year
        years = self.df['date'].dt.year.unique()
        for year in sorted(years):
            # Create a year-level widget
            year_widget = QWidget(dialog)
            year_layout = QVBoxLayout(year_widget)

            # Year-level checkbox (above all content for the year)
            year_checkbox = QCheckBox(f"Select All in {year}", dialog)
            year_checkbox.setChecked(
                True if self.recorte_datas is None else all(str(date.date()) in self.recorte_datas for date in self.df[self.df['date'].dt.year == year]['date'])
            )
            year_checkbox.stateChanged.connect(lambda state, yr=year: self.toggle_year_checkboxes(yr, state))
            scroll_layout.addWidget(year_checkbox)
            self.year_checkboxes[year] = year_checkbox

            # Indented content for the year
            year_content_widget = QWidget(dialog)
            year_content_layout = QVBoxLayout(year_content_widget)
            year_content_layout.setContentsMargins(20, 0, 0, 0)  # Add indentation for year content
            scroll_layout.addWidget(year_content_widget)

            # Add months under each year
            for (group_year, month), group in grouped:
                if group_year != year:
                    continue

                # Create a month-level widget
                group_label = f"{group_year}-{month:02d}"
                month_widget = QWidget(dialog)
                month_layout = QVBoxLayout(month_widget)

                # Month toggle button
                month_toggle_button = QToolButton(dialog)
                month_toggle_button.setText(f"▶ {group_label}")
                month_toggle_button.setCheckable(True)
                month_toggle_button.setChecked(True)
                month_toggle_button.setStyleSheet("text-align: left;")
                month_toggle_button.toggled.connect(
                    lambda checked, grp=month_widget, btn=month_toggle_button, lbl=group_label: self.toggle_group_visibility(grp, btn, lbl)
                )

                # Month-level checkbox
                group_checkbox = QCheckBox(f"Select All in {group_label}", dialog)
                group_checkbox.setChecked(
                    True if self.recorte_datas is None else all(str(date.date()) in self.recorte_datas for date in group['date'])
                )
                group_checkbox.stateChanged.connect(lambda state, grp=group_label: self.toggle_group_checkboxes(grp, state))
                month_layout.addWidget(group_checkbox)
                self.group_checkboxes[group_label] = group_checkbox

                # Add individual checkboxes with further indentation
                for date in group['date']:
                    date_str = str(date.date())
                    checkbox = QCheckBox(date_str, dialog)
                    checkbox.setChecked(True if self.recorte_datas is None else date_str in self.recorte_datas)
                    month_layout.addWidget(checkbox)
                    checkbox.setContentsMargins(20, 0, 0, 0)  # Further indentation for dates
                    self.checkboxes.append((checkbox, group_label, group_year))

                # Add month layout to the year content layout
                year_content_layout.addWidget(month_toggle_button)
                year_content_layout.addWidget(month_widget)
                self.group_widgets[group_label] = month_widget

        scroll_content.setLayout(scroll_layout)
        scroll_area.setWidget(scroll_content)
        layout.addWidget(scroll_area)

        # Buttons
        button_box = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel, dialog)
        button_layout = QHBoxLayout()
        apply_button = QPushButton("Apply", dialog)
        select_button = QPushButton("Select All", dialog)
        deselect_button = QPushButton("Deselect All", dialog)
        button_layout.addWidget(apply_button)
        button_layout.addWidget(select_button)
        button_layout.addWidget(deselect_button)
        layout.addLayout(button_layout)
        layout.addWidget(button_box)

        # Signal Connections
        button_box.accepted.connect(dialog.accept)
        button_box.rejected.connect(dialog.reject)
        apply_button.clicked.connect(self.apply_changes)  # Apply without closing
        select_button.clicked.connect(self.select_all_checkboxes)
        deselect_button.clicked.connect(self.deselect_all_checkboxes)

        if dialog.exec_() == QDialog.Accepted:
            self.apply_changes()  # Ensure changes are applied before closing
        else:
            print("Time series dialog canceled. No changes made.")

    def apply_changes(self):
        """Apply changes without closing the dialog."""
        self.selected_dates = [cb.text() for cb, _, _ in self.checkboxes if cb.isChecked()]
        self.recorte_datas = self.selected_dates
        print(f"Selected dates for time series (applied): {self.recorte_datas}")
        self.df_ajust()
        self.plot_timeseries()

    def toggle_group_visibility(self, group_widget, toggle_button, group_label):
        """Toggle visibility of a group widget."""
        group_widget.setVisible(toggle_button.isChecked())
        toggle_button.setText(f"▶ {group_label}" if not toggle_button.isChecked() else f"▼ {group_label}")

    def toggle_group_checkboxes(self, group_label, state):
        """Toggle all checkboxes in a month group."""
        for checkbox, group, _ in self.checkboxes:
            if group == group_label:
                checkbox.setChecked(state == Qt.Checked)

    def toggle_year_checkboxes(self, year, state):
        """Toggle all checkboxes in a year group."""
        for checkbox, _, group_year in self.checkboxes:
            if group_year == year:
                checkbox.setChecked(state == Qt.Checked)
        for group_label, group_checkbox in self.group_checkboxes.items():
            if group_label.startswith(str(year)):
                group_checkbox.setChecked(state == Qt.Checked)

    def select_all_checkboxes(self):
        for checkbox, _, _ in self.checkboxes:
            checkbox.setChecked(True)
        for group_checkbox in self.group_checkboxes.values():
            group_checkbox.setChecked(True)
        for year_checkbox in self.year_checkboxes.values():
            year_checkbox.setChecked(True)

    def deselect_all_checkboxes(self):
        for checkbox, _, _ in self.checkboxes:
            checkbox.setChecked(False)
        for group_checkbox in self.group_checkboxes.values():
            group_checkbox.setChecked(False)
        for year_checkbox in self.year_checkboxes.values():
            year_checkbox.setChecked(False)

    def centralizar(self):
        qtRectangle = self.frameGeometry()
        centerPoint = QDesktopWidget().availableGeometry().center()
        qtRectangle.moveCenter(centerPoint)
        self.move(qtRectangle.topLeft())
        qtRectangle = self.frameGeometry()
        centerPoint = QDesktopWidget().availableGeometry().center()
        qtRectangle.moveCenter(centerPoint)
        self.move(qtRectangle.topLeft())

    def resizeEvent(self, event):
        if event == 'pequeno':
            self.resize(445, 290)
        elif event == 'grandao':
            self.resize(1145, 610)
            self.centralizar()

    def on_tab_changed(self, index):
        print(f"Tab changed to index: {index}")

        if not self.autentication:
            self.tabWidget.setCurrentIndex(0)
            return
        if index == 0:
                    self.resizeEvent('pequeno')  
        elif index == 1:
                    self.resizeEvent('pequeno')
        elif index == 2:
                    self.resizeEvent('pequeno') 
        elif index == 3:
            self.resizeEvent('grandao')
            self.centralizar()
        elif index == 3 and self.df is not None:
            self.resizeEvent('grandao')
            self.centralizar()
            self.plot_timeseries()

    def next_clicked(self):
        current_index = self.tabWidget.currentIndex()
        next_index = (current_index + 1) % self.tabWidget.count()
        self.tabWidget.setCurrentIndex(next_index)

    def back_clicked(self):
        current_index = self.tabWidget.currentIndex()
        next_index = (current_index - 1) % self.tabWidget.count()
        self.tabWidget.setCurrentIndex(next_index)

    def auth(self):
    # Attempt to initialize Earth Engine
        try:
            ee.Authenticate()
            ee.Initialize()
            self.pop_aviso("Authentication successful!")
            self.autentication = True
            # self.pushButtonNext.setEnabled(True)
            self.tabWidget.setCurrentIndex(1)
            print("Authentication successful!")

        except ee.EEException as e:
            if "Earth Engine client library not initialized" in str(e):
                self.pop_aviso("Authentication failed. Please authenticate.")
                print("Authentication failed. Please authenticate.")
                ee.Authenticate()
                ee.Initialize()  # Retry after authentication
            else:
                print(f"An error occurred: {e}")

    def auth_clear(self):
        print('Desautenticando...')
        """Clears the Earth Engine authentication by deleting the credentials file."""
        
        system = platform.system()
        
        # Set the path for Earth Engine credentials based on the operating system
        if system == 'Windows':
            credentials_path = os.path.join(os.environ['USERPROFILE'], '.config', 'earthengine', 'credentials')
        elif system == 'Linux':
            credentials_path = os.path.join(os.environ['HOME'], '.config', 'earthengine', 'credentials')
        elif system == 'Darwin':  # MacOS
            credentials_path = os.path.join(os.environ['HOME'], 'Library', 'Application Support', 'earthengine', 'credentials')
        else:
            raise Exception(f"Unsupported operating system: {system}")

        # Check if the credentials file exists and delete it
        if os.path.exists(credentials_path):
            os.remove(credentials_path)
            self.pop_aviso("Autenticação do Earth Engine limpa com sucesso")
            print("Earth Engine authentication cleared successfully.")
        else:
            self.pop_aviso("Nenhuma credencial do Earth Engine encontrada para limpar.")
            print("No Earth Engine credentials found to clear.")

    def get_dates(self):
        # Get the date from the QDateEdit widget
        self.inicio = self.incioedit.date().toString("yyyy-MM-dd")

        self.final = self.finaledit.date().toString("yyyy-MM-dd")
        print(f"Selected date: {self.inicio} to {self.final}")

        # Get the selected text from the combobox
        self.nuvem = self.horizontalSlider_3.value()
        print(f"Nuvem limit: {self.nuvem}")

    def pop_aviso(self, aviso):
        QApplication.restoreOverrideCursor()
        msg = QMessageBox(parent=self)
        msg.setWindowTitle("Warning!")
        msg.setIcon(QMessageBox.Warning)
        msg.setText(aviso)
        msg.setStandardButtons(QMessageBox.Ok | QMessageBox.Cancel)  # Add Ok and Cancel buttons

        ret = msg.exec_()  # Get the result of the dialog

        if ret == QMessageBox.Ok:
            
            # Handle Ok button click
            print("Ok button clicked")
            # Add your code here for what to do when Ok is clicked
            return True
        elif ret == QMessageBox.Cancel:
            
            # Handle Cancel button click
            print("Cancel button clicked")
            # Add your code here for what to do when Cancel is clicked
            return False

    def update_vector_clicked(self):
        self.comboBox.clear()

        # Get the list of all layers in the current QGIS project
        layers = QgsProject.instance().layerTreeRoot().children()

        # Iterate through the layers and add vector layer names to the ComboBox
        for layer in layers:
            if layer.layer().type() == QgsMapLayer.VectorLayer:  # Check if it's a vector layer
                self.comboBox.addItem(layer.layer().name())

        # Optional: Set the first item as the current selection
        if self.comboBox.count() > 0:
            self.comboBox.setCurrentIndex(0)

    def load_vector_layers(self) -> None:
        layers = QgsProject.instance().mapLayers().values()
        self.vector_layer_combobox.clear()
        self.vector_layer_ids = {}
        
        for layer in layers:
            if layer.type() == QgsMapLayer.VectorLayer:
                layer_name = layer.name()
                print(f"Adding layer: {layer_name}")  # Debug: Show added layer names
                self.vector_layer_combobox.addItem(layer_name)
                self.vector_layer_ids[layer_name] = layer.id()
        
        # Debug: Show the layer dictionary after loading
        print(f"Loaded vector layers: {self.vector_layer_ids}")
        self.get_selected_layer_path()

    def get_selected_layer_path(self) -> str:
        layer_name = self.vector_layer_combobox.currentText()
        self.zoom_to_layer(layer_name)
        print(f"Selected layer name: {layer_name}")  # Debug: Show selected layer name
        
        layer_id = self.vector_layer_ids.get(layer_name)
        if not layer_id:
            print(f"Layer ID for '{layer_name}' not found in vector_layer_ids.")
            return None
        
        layer = QgsProject.instance().mapLayer(layer_id)
        if layer:
            print(f"Layer found: {layer.name()}, ID: {layer_id}")  # Debug: Confirm layer is found
            print(f"Layer data provider: {layer.dataProvider().dataSourceUri().split('|')[0]}")  # Debug: Show layer data source URI

            shapefile_extensions = [
                            ".shp",       # Shapefile
                            ".gpkg",      # GeoPackage
                            ".geojson",   # GeoJSON
                            ".json",      # GeoJSON alternative
                            ".kml",       # KML
                            ".kmz",       # KMZ (zipped KML)
                            ".csv",       # CSV with spatial data
                            ".gpx",       # GPX (GPS Exchange Format)
                            ".sqlite",    # SQLite/SpatiaLite
                            ".tab",       # MapInfo TAB
                            ".mif",       # MapInfo MIF
                            ".dxf",       # DXF (AutoCAD)
                            ".gml",       # GML (Geography Markup Language)
                            ".osm",       # OpenStreetMap
                            ".topojson",  # TopoJSON
                            ".vrt",       # Virtual Format
                            ".dgn",       # DGN (MicroStation Design Files)
                            ".gmt",       # GMT (Generic Mapping Tools)
                            ".svg",       # Scalable Vector Graphics
                            ".rt1",       # TIGER/Line
                            ".rt2",       # TIGER/Line
                            ".gdb",       # ESRI File Geodatabase
                            ".thf",       # EDIGEO
                            ".xlsx",      # Excel with geometry
                            ".ods"        # OpenDocument Spreadsheet with geometry
                        ]


            # Check if the layer's data source URI contains any of the shapefile extensions
            if any(ext in layer.dataProvider().dataSourceUri().lower() for ext in shapefile_extensions):
                self.selected_aio_layer_path = layer.dataProvider().dataSourceUri().split('|')[0]
                print(f"Selected layer path: {self.selected_aio_layer_path}")
                self.load_vector_function()
                # Enable next
                return None
            else:
                print(f"Layer '{layer_name}' is not a shapefile.")
                return None
        else:
            print(f"Layer '{layer_name}' with ID '{layer_id}' not found in the project.")
            return None

    def first_index(self):
        print("First index clicked")
        QApplication.setOverrideCursor(Qt.WaitCursor)
        vegetation_index = self.imagem_unica_indice.currentText()
    
        ee.Initialize()
        startDate = self.dataunica.currentText()
        date_obj = datetime.strptime(startDate, "%Y-%m-%d")
        endDate = (date_obj + relativedelta(days=+1)).strftime("%Y-%m-%d")

        print(f"Filtering images from {startDate} to {endDate}")

        first_image = self.sentinel2.filterDate(startDate, endDate).first()
        first_image = first_image.clip(self.aoi)

        # Calculate the selected vegetation index
        if vegetation_index == 'NDVI':
            index_image = first_image.normalizedDifference(['B8', 'B4']).rename('NDVI')
        elif vegetation_index == 'GNDVI':
            index_image = first_image.normalizedDifference(['B8', 'B3']).rename('GNDVI')
        elif vegetation_index == 'EVI':
            index_image = first_image.expression(
                '2.5 * ((NIR / 10000 - RED / 10000) / (NIR / 10000 + 6 * RED / 10000 - 7.5 * BLUE / 10000 + 1))', {
                    'NIR': first_image.select('B8'),
                    'RED': first_image.select('B4'),
                    'BLUE': first_image.select('B2')
                }
            ).rename('EVI')
        elif vegetation_index == 'SAVI':
            L = 0.5  # Adjust L value as needed
            index_image = first_image.expression(
                '(1 + L) * ((NIR / 10000) - (RED / 10000)) / ((NIR / 10000) + (RED / 10000) + L)', {
                    'NIR': first_image.select('B8'),
                    'RED': first_image.select('B4'),
                    'L': L
                }
            ).rename('SAVI')
        else:
            print(f"Unsupported vegetation index: {vegetation_index}")
            return

        date = ee.Date(first_image.get('system:time_start')).format('YYYY-MM-dd').getInfo()

        url = index_image.getDownloadUrl({
            'scale': 10,
            'region': self.aoi.geometry().bounds().getInfo(),
            'format': 'GeoTIFF'
        })

        base_output_file = f'{vegetation_index}_{date}' 
        output_file = self.get_unique_filename(base_output_file)

        response = requests.get(url)
        with open(output_file, 'wb') as f:
            f.write(response.content)

        print(f"{vegetation_index} image downloaded as {output_file}")

        layer_name = f'{vegetation_index} {date}'

        # **Prevent Duplicate Layers by Checking Existing Layers**
        existing_layers = QgsProject.instance().mapLayersByName(layer_name)
        if existing_layers:
            base_name = layer_name
            i = 1
            while QgsProject.instance().mapLayersByName(layer_name):
                layer_name = f"{base_name}_{i}"
                i += 1
            print(f"Layer name adjusted to '{layer_name}' to ensure uniqueness.")        

        self.load_raster_layer_colorful(output_file, layer_name, vegetation_index)

    def first_rgb(self):
        """
        Fetches the first Sentinel-2 image for the selected date, downloads it,
        and adds it as an RGB layer in QGIS.
        """
        # Set the cursor to indicate processing
        QApplication.setOverrideCursor(Qt.WaitCursor)
        try:
            # Initialize Earth Engine
            try:
                ee.Initialize()
            except Exception as e:
                print(f"Earth Engine initialization failed: {e}")
                return

            # Retrieve and validate the selected start date
            startDate = self.dataunica.currentText()
            try:
                date_obj = datetime.strptime(startDate, "%Y-%m-%d")
            except ValueError as ve:
                print(f"Invalid date format: {ve}")
                return

            # Calculate the end date as one day after the start date
            endDate = (date_obj + relativedelta(days=1)).strftime("%Y-%m-%d")
            print(f"Filtering images from {startDate} to {endDate}")

            # Filter the Sentinel-2 collection for the specified date range
            sentinel_collection = self.sentinel2.filterDate(startDate, endDate)
            first_image = sentinel_collection.first()

            # Check if any image is found
            if not first_image:
                print("No Sentinel-2 images found for the selected date.")
                return

            # Clip the image to the Area of Interest (AOI)
            first_image = first_image.clip(self.aoi)

            # Retrieve the acquisition date of the image
            date = ee.Date(first_image.get('system:time_start')).format('YYYY-MM-dd').getInfo()

            # Define the region for downloading (bounding box of AOI)
            region = self.aoi.geometry().bounds().getInfo()['coordinates']

            # Generate the download URL for the image in GeoTIFF format
            url = first_image.getDownloadUrl({
                'scale': 10,  # 10-meter resolution
                'region': region,
                'format': 'GeoTIFF'
            })

            # Define a unique output file name with .tif extension
            base_output_file = f'Sentinel2_AllBands_{date}.tif'
            output_file = self.get_unique_filename(base_output_file)

            # Download the image
            try:
                response = requests.get(url, stream=True)
                response.raise_for_status()
                with open(output_file, 'wb') as f:
                    for chunk in response.iter_content(chunk_size=8192):
                        if chunk:  # Filter out keep-alive chunks
                            f.write(chunk)
                print(f"Sentinel-2 all bands image downloaded as {output_file}")
            except requests.exceptions.RequestException as e:
                print(f"Error downloading the image: {e}")
                return

            # Define the layer name
            layer_name = f'Sentinel-2 RGB {date}'

            # **Prevent Duplicate Layers by Checking Existing Layers**
            existing_layers = QgsProject.instance().mapLayersByName(layer_name)
            if existing_layers:
                base_name = layer_name
                i = 1
                while QgsProject.instance().mapLayersByName(layer_name):
                    layer_name = f"{base_name}_{i}"
                    i += 1
                print(f"Layer name adjusted to '{layer_name}' to ensure uniqueness.")

            # Create a QGIS raster layer from the downloaded GeoTIFF
            layer = QgsRasterLayer(output_file, layer_name)

            # Verify that the layer is valid
            if not layer.isValid():
                print(f"Failed to load layer: {output_file}")
                return

            # Set min and max values for each band (Red, Green, Blue)
            min_val, max_val = 200, 2300

            # Create a new MultiBandColorRenderer for RGB
            renderer = QgsMultiBandColorRenderer(
                layer.dataProvider(),
                4,  # Red band (B4, 1-based index)
                3,  # Green band (B3)
                2   # Blue band (B2)
            )

            # Set contrast enhancement for each band (Red, Green, Blue)
            try:
                red_ce = QgsContrastEnhancement(layer.dataProvider().dataType(4))
                red_ce.setMinimumValue(min_val)
                red_ce.setMaximumValue(max_val)
                red_ce.setContrastEnhancementAlgorithm(QgsContrastEnhancement.StretchToMinimumMaximum)

                green_ce = QgsContrastEnhancement(layer.dataProvider().dataType(3))
                green_ce.setMinimumValue(min_val)
                green_ce.setMaximumValue(max_val)
                green_ce.setContrastEnhancementAlgorithm(QgsContrastEnhancement.StretchToMinimumMaximum)

                blue_ce = QgsContrastEnhancement(layer.dataProvider().dataType(2))
                blue_ce.setMinimumValue(min_val)
                blue_ce.setMaximumValue(max_val)
                blue_ce.setContrastEnhancementAlgorithm(QgsContrastEnhancement.StretchToMinimumMaximum)

                renderer.setRedContrastEnhancement(red_ce)
                renderer.setGreenContrastEnhancement(green_ce)
                renderer.setBlueContrastEnhancement(blue_ce)
            except AttributeError as ae:
                print(f"Error configuring renderer: {ae}")
                return
            except Exception as e:
                print(f"Unexpected error configuring renderer: {e}")
                return

            # Set the renderer to the layer
            layer.setRenderer(renderer)

            # **Add the raster layer to the QGIS project only once**
            QgsProject.instance().addMapLayer(layer)
            print(f"Layer '{layer_name}' added to QGIS.")

            # **Move the layer to the top of the layer stack**
            layer_tree_root = QgsProject.instance().layerTreeRoot()
            layer_node = layer_tree_root.findLayer(layer.id())
            if layer_node:
                layer_tree_root.insertChildNode(0, layer_node.clone())  # Clone to preserve node
                layer_tree_root.removeChildNode(layer_node)  # Remove the original node
                print(f"Layer '{layer_name}' moved to the top of the layer stack.")
            else:
                print(f"Layer '{layer_name}' not found in the layer tree.")

            # Access the QGIS interface and map canvas
            iface = qgis.utils.iface
            canvas = iface.mapCanvas()  # Access the active map canvas

            # Ensure the canvas CRS matches the layer CRS
            canvas.setDestinationCrs(layer.crs())

            # Zoom to the layer's extent
            layer_extent = layer.extent()
            canvas.setExtent(layer_extent)
            canvas.refresh()
            print(f"Zoomed to layer extent: {layer_extent.toString()}")
        finally:
            QApplication.restoreOverrideCursor()

    def zoom_to_layer(self, layer_name, margin_ratio=0.1):
        """
        Zoom to the specified layer with an optional margin.

        :param layer_name: Name of the layer to zoom to.
        :param margin_ratio: Fraction of the extent to add as margin (default is 0.1, or 10%).
        """
        project = QgsProject.instance()
        layers = project.mapLayersByName(layer_name)  # Get layers matching the name
        
        if not layers:
            print(f"Layer '{layer_name}' not found.")
            return
        
        layer = layers[0]  # Use the first matching layer
        iface = qgis.utils.iface  # Access the QGIS interface
        canvas = iface.mapCanvas()  # Get the active map canvas
        
        # Ensure the canvas CRS matches the layer CRS
        canvas.setDestinationCrs(layer.crs())
        
        # Get the layer's extent and add a margin
        layer_extent = layer.extent()
        x_margin = layer_extent.width() * margin_ratio
        y_margin = layer_extent.height() * margin_ratio
        
        expanded_extent = QgsRectangle(
            layer_extent.xMinimum() - x_margin,
            layer_extent.yMinimum() - y_margin,
            layer_extent.xMaximum() + x_margin,
            layer_extent.yMaximum() + y_margin
        )
        
        # Set the expanded extent to the canvas
        canvas.setExtent(expanded_extent)
        canvas.refresh()
        
        print(f"Zoomed to layer extent with margin: {expanded_extent.toString()}")

    def get_unique_filename(self, base_file_name):
        """
        Generates a unique filename by checking if the file already exists
        and adding a numerical suffix to it if needed.

        Parameters:
        base_file_name (str): The base filename to use.

        Returns:
        str: The unique filename.
        """
        output_file = self.output_folder+f'/{base_file_name}.tif'
        counter = 1

        while os.path.exists(output_file):
            output_file = self.output_folder +f'/{base_file_name}_{counter}.tif'
            counter += 1

        print(f"Unique filename: {output_file}")
        return output_file
    
    def get_unique_filename_shp(self, base_file_name):
        """
        Generates a unique filename by checking if the file already exists
        and adding a numerical suffix to it if needed.

        Parameters:
        base_file_name (str): The base filename to use.

        Returns:
        str: The unique filename.
        """
        output_file = self.output_folder+f'/{base_file_name}.shp'
        counter = 1

        while os.path.exists(output_file):
            output_file = self.output_folder +f'/{base_file_name}_{counter}.shp'
            counter += 1

        print(f"Unique filename: {output_file}")
        return output_file

    def composicao_clicked(self):
        QApplication.setOverrideCursor(Qt.WaitCursor)
        print("Composição de índices vegetativos")
        indice_vegetacao = self.indice_composicao.currentText()
        metrica = self.metrica.currentText()
        """
        Calculates and downloads an image from Sentinel-2 data for a specified 
        area of interest, time range, vegetation index, and metric. 
        If a file with the same name exists, it adds a numerical suffix 
        to the filename to avoid overwriting. Then loads the image into QGIS.
        """

        Date_list_selection = [date.strftime('%Y-%m-%d') for date in pd.to_datetime(self.df_aux['date']).tolist()] if 'date' in self.df_aux.columns else []
        print(f"Selected dates for time series: {Date_list_selection}")


        Original_list = self.sentinel2.aggregate_array('system:time_start').getInfo()

        print("Final number of images before:", self.sentinel2.size().getInfo())

        Date_list_selection = [int(datetime.strptime(date, '%Y-%m-%d').timestamp()) for date in Date_list_selection]
        Original_list = list(map(int, Original_list))
        # Convert each timestamp in Original_list to a formatted date string
        formatted_dates_original = [datetime.fromtimestamp(ts / 1000).strftime('%Y-%m-%d') for ts in Original_list]
        df = pd.DataFrame(list(zip(Original_list, formatted_dates_original)), columns =['Original_list', 'formatted_dates_original'])
        formatted_dates_selection = [datetime.fromtimestamp(ts).strftime('%Y-%m-%d') for ts in Date_list_selection]
        new = df[df['formatted_dates_original'].isin(formatted_dates_selection)].Original_list.tolist()
        # new = list(map(str, new))

        # Filter the collection by the dates
        sentinel2_selected_dates = self.sentinel2.filter(
            ee.Filter.inList('system:time_start', ee.List(new))
        )

        print("Final number of images after:", sentinel2_selected_dates.size().getInfo())

        # Calculate the specified vegetation index for each image in the collection
        def calculate_index(image):
            if indice_vegetacao == 'NDVI':
                return image.normalizedDifference(['B8', 'B4']).rename('NDVI')
            elif indice_vegetacao == 'EVI':
                return image.expression(
                    '2.5 * ((NIR / 10000 - RED / 10000) / (NIR / 10000 + 6 * RED / 10000 - 7.5 * BLUE / 10000 + 1))', {
                        'NIR': image.select('B8'),
                        'RED': image.select('B4'),
                        'BLUE': image.select('B2')
                    }).rename('EVI')
            elif indice_vegetacao == 'SAVI':
                return image.expression(
                    '(1 + L) * ((NIR / 10000) - (RED / 10000)) / ((NIR / 10000) + (RED / 10000) + L)', {
                        'NIR': image.select('B8'),
                        'RED': image.select('B4'),
                        'L': 0.5  # Adjust L value as needed
                    }).rename('SAVI')
            elif indice_vegetacao == 'GNDVI':
                return image.normalizedDifference(['B8', 'B3']).rename('GNDVI')         
            else:
                raise ValueError(f"Invalid indice_vegetacao: {indice_vegetacao}")

        index_collection = sentinel2_selected_dates.map(calculate_index)

        # Apply the specified metric to the vegetation index collection
        if metrica == 'Mean':
            final_image = index_collection.mean()
        elif metrica == 'Max':
            final_image = index_collection.max()
        elif metrica == 'Min':  
            final_image = index_collection.min()
        elif metrica == 'Median':
            final_image = index_collection.median()
        elif metrica == 'Amplitude':
            final_image = index_collection.max().subtract(index_collection.min())
        else:
            raise ValueError(f"Invalid metric: {metrica}")
        
        final_image = final_image.clip(self.aoi.geometry())

        url = final_image.getDownloadUrl({
            'scale': 10,
            'region': self.aoi.geometry().bounds().getInfo(),
            'format': 'GeoTIFF'
        })

        base_output_file = f'{metrica}_{indice_vegetacao}' 
        output_file = self.get_unique_filename(base_output_file)

        response = requests.get(url)
        with open(output_file, 'wb') as f:
            f.write(response.content)

        print(f"{indice_vegetacao} image downloaded as {output_file}")

        layer_name = f'{indice_vegetacao} {metrica}'
        
        base_output_file = f'{metrica}_{indice_vegetacao}_clipped' 
        output_file_clipped = self.get_unique_filename(base_output_file)

        self.clip_raster_by_vector(output_file, self.selected_aio_layer_path, output_file_clipped, layer_name)

        self.load_raster_layer_colorful(output_file_clipped, layer_name, indice_vegetacao)

    def clip_raster_by_vector(self, raster_path, shapefile_path, output_path, layer_name):
        print(f"Clipping raster {raster_path} by vector {shapefile_path} to {output_path}")
        # Load layers
        shapefile_layer = QgsVectorLayer(shapefile_path, "Clip Layer", "ogr")
        raster_layer = QgsRasterLayer(raster_path, "Raster Layer")

        # Check if layers loaded successfully
        if not shapefile_layer.isValid():
            print("Failed to load shapefile.")
        if not raster_layer.isValid():
            print("Failed to load raster.")

        # Clip raster using the shapefile
        result = processing.run(
            "gdal:cliprasterbymasklayer",
            {
                'INPUT': raster_layer,
                'MASK': shapefile_layer,
                'NODATA': -9999,  # Change to appropriate NoData value if needed
                'CROP_TO_CUTLINE': True,
                'KEEP_RESOLUTION': True,
                'OUTPUT': output_path
            },
            feedback=QgsProcessingFeedback()
        )

        print(f"Clipping result: {result}")

        # # Load the clipped raster into QGIS
        # clipped_layer = QgsRasterLayer(output_path, "Clipped Raster")
        # if clipped_layer.isValid():
        #     QgsProject.instance().addMapLayer(clipped_layer)
        #     print(f"Clipped raster saved and added to QGIS: {output_path}")
        # else:
        #     print("Failed to add the clipped raster to QGIS.")
        
    def on_file_changed(self, file_path):
        """Slot called when the selected file changes."""
        print(f"File selected: {file_path}")
        self.output_folder = file_path
        self.folder_set = True
        self.aoi_ckecked_function()
        # self.check_next_button()

    def load_vector_function(self):
        shapefile_path = self.selected_aio_layer_path
        
        # Check if the path is a .zip file
        if shapefile_path.endswith('.zip'):
            # Try to read shapefile from a zip archive
            try:
                # Check if the .zip file exists and open it
                with zipfile.ZipFile(shapefile_path, 'r') as zip_ref:
                    zip_ref.printdir()  # Optional: Print contents of the zip to debug
                    # Try to find the .shp file inside the zip
                    shapefile_found = False
                    for file in zip_ref.namelist():
                        if file.endswith('.shp'):
                            shapefile_found = True
                            shapefile_within_zip = file
                            break
                    
                    if shapefile_found:
                        # Read shapefile directly from the zip file
                        self.aoi = gpd.read_file(f'zip://{shapefile_path}/{shapefile_within_zip}')
                        print(f"Successfully loaded shapefile from {shapefile_path}.")
                    else:
                        print("No .shp file found inside the zip archive.")
                        return
            except Exception as e:
                print(f"Error reading shapefile from zip archive: {e}")
                return

        else:
            # If not a .zip, assume it is a regular shapefile
            try:
                # Read the shapefile normally
                # Use the project's CRS to read the shapefile
                self.aoi = gpd.read_file(shapefile_path).to_crs("EPSG:4326")
                print(f"Successfully loaded shapefile from {shapefile_path}.")
            except Exception as e:
                print(f"Error reading shapefile: {e}")
                return
        
        # After loading, check if the GeoDataFrame is not empty
        if not self.aoi.empty:
            # If the GeoDataFrame contains multiple geometries, dissolve them into one
            if len(self.aoi) > 1:
                self.aoi = self.aoi.dissolve()

            # Extract the first geometry from the dissolved GeoDataFrame
            geometry = self.aoi.geometry.iloc[0]

            # Check if the geometry is a Polygon or MultiPolygon
            if geometry.geom_type in ['Polygon', 'MultiPolygon']:
                # Convert the geometry to GeoJSON format
                geojson = geometry.__geo_interface__

                # Remove the third dimension from the coordinates if it exists
                if geojson['type'] == 'Polygon':
                    geojson['coordinates'] = [list(map(lambda coord: coord[:2], ring)) for ring in geojson['coordinates']]
                elif geojson['type'] == 'MultiPolygon':
                    geojson['coordinates'] = [[list(map(lambda coord: coord[:2], ring)) for ring in polygon] for polygon in geojson['coordinates']]

                # Create an Earth Engine geometry object from the GeoJSON coordinates
                ee_geometry = ee.Geometry(geojson)

                # Convert the Earth Engine geometry to a Feature
                feature = ee.Feature(ee_geometry)

                # Create a FeatureCollection with the feature
                self.aoi = ee.FeatureCollection([feature])

                buffer = int(self.buffer.currentText())
                print(f"Buffer: {buffer}")
                if buffer > 0:
                    self.aio = self.aoi.map(lambda feature: feature.buffer(buffer))


                print("AOI defined successfully.")
                
                self.aoi_ckecked  = True
                self.aoi_ckecked_function()

                # self.check_next_button()
            else:
                
                print("The geometry is not a valid type (Polygon or MultiPolygon).")
                self.pop_aviso("The geometry is not a valid type (Polygon or MultiPolygon).")
        else:
            print("The shapefile does not contain any geometries.")
            self.pop_aviso("The shapefile does not contain any geometries.")

    def find_centroid(self):
        centroid = self.aoi.geometry().centroid()
        self.lat = centroid.getInfo().get('coordinates')[1]
        self.lon = centroid.getInfo().get('coordinates')[0]
        print(f"Latitude: {self.lat}, Longitude: {self.lon}")
        area = self.aoi.geometry().area().getInfo() / 1e6  # Convert from square meters to square kilometers
        print(f"Area: {area:.2f} km²")
        if area >= 100:
            self.aoi = None
            self.aoi_ckecked = False
            self.aoi_ckecked_function()
            return area
        else:
            return 0

    def open_nasapower(self):
        longitude = str(self.lon)
        latitude = str(self.lat)
        start = self.df_aux.date.tolist()[0]
        end = self.df_aux.date.tolist()[-1]
        print(f"Latitude: {latitude}, Longitude: {longitude}")
        print(f"Start date: {start}, End date: {end}")
        print("Opening NASA POWER data for the selected location...")

        start_date = datetime.strptime(start, "%Y-%m-%d")
        end_date = datetime.strptime(end, "%Y-%m-%d")

        new_start = start_date.replace(day=1).strftime("%Y%m%d")
        new_end = (end_date.replace(day=1) + timedelta(days=32)).replace(day=1) - timedelta(days=1)
        new_end = new_end.strftime("%Y%m%d")
        print(new_start, new_end)


        base_url = (f"https://power.larc.nasa.gov/api/temporal/daily/point?parameters=PRECTOTCORR&community=RE&longitude={longitude}&latitude={latitude}&start={new_start}&end={new_end}&format=JSON")
        api_request_url = base_url.format(longitude=longitude, latitude=latitude)
        response = requests.get(url=api_request_url, verify=True, timeout=1000)
        content = json.loads(response.content.decode('utf-8'))
        df = pd.DataFrame.from_dict(content['properties']['parameter'])
        df[df < 0] = 0
        # Convert the index to datetime
        df.index = pd.to_datetime(df.index, format='%Y%m%d')

        # Resample the data to monthly frequency and sum the values
        monthly_sum = df.resample('M').sum()
        print(monthly_sum)
        self.df_nasa = monthly_sum
        self.plot_timeseries()

    def aoi_ckecked_function(self):
        if self.aoi_ckecked and self.folder_set:
            self.pushButtonNext.setEnabled(True)
        else:
            self.pushButtonNext.setEnabled(False)

    def apply_filter_clicked(self):
        if not self.customfilter.isChecked():
            self.loadtimeseries_clicked()
            return
        else:
            QApplication.setOverrideCursor(Qt.WaitCursor)

        self.recorte_datas = None
        self.load_vector_function()
        self.get_dates()

        sentinel2 = self.sentinel2

        # Define a function to mask clouds and shadows in the images
        def mask_cloud_and_shadows(image):
            # Check if the cloud probability and snow probability bands are available
            band_names = image.bandNames()
            has_cloud_prob = band_names.contains('MSK_CLDPRB')
            has_snow_prob = band_names.contains('MSK_SNWPRB')

            # Create masks based on the availability of the bands
            cloud_mask = ee.Image(1) if not has_cloud_prob else image.select('MSK_CLDPRB').lt(1)
            snow_mask = ee.Image(1) if not has_snow_prob else image.select('MSK_SNWPRB').lt(1)

            # Scene classification layer
            scl = image.select('SCL')
            shadow_mask = scl.neq(3)  # Shadow class
            cirrus_mask = scl.neq(10)  # Cirrus class

            # Combine all masks
            mask = cloud_mask.And(snow_mask).And(shadow_mask).And(cirrus_mask)
            return image.updateMask(mask)

        # Apply the cloud and shadow mask function to the image collection
        masked_sentinel2 = sentinel2.map(mask_cloud_and_shadows)

        valid_pixel_ratio_threshold = self.horizontalSlider.value()/100

        # Assuming 'aoi' is a predefined FeatureCollection
        aoi_geometry = self.aoi.first().geometry()

        # Calculate the area of the AOI geometry in square meters
        aoi_area = aoi_geometry.area()

        def calculate_valid_pixel_ratio(image):
            # Select the QA60 band which contains cloud mask information
            qa = image.select('QA60')
            
            # Identify non-cloudy pixels (QA60 == 0)
            non_cloudy = qa.eq(0)
            
            # Count the number of valid (non-cloudy) pixels within the AOI
            valid_pixels = non_cloudy.reduceRegion(
                reducer=ee.Reducer.sum(),
                geometry=aoi_geometry,
                scale=20,  # Updated scale to 20 meters for QA60
                bestEffort=True,
                maxPixels=1e9
            ).get('QA60')
            
            # Calculate the total number of pixels in the AOI
            # Since QA60 has 20m resolution, each pixel represents 400 m²
            total_pixels = ee.Number(aoi_area).divide(400).round()
            
            # Calculate the ratio of valid pixels to total pixels
            valid_pixel_ratio = ee.Number(valid_pixels).divide(total_pixels)
            
            # Set the valid pixel ratio as a property of the image
            return image.set('valid_pixel_ratio', valid_pixel_ratio)

        # Map the valid pixel ratio calculation function over the image collection
        masked_sentinel2_ratio = masked_sentinel2.map(calculate_valid_pixel_ratio)

        # Create a filter to keep images with valid_pixel_ratio greater than or equal to the threshold
        coverage_filter = ee.Filter.gte('valid_pixel_ratio', valid_pixel_ratio_threshold)

        # Apply the filter to get the final image collection with sufficient valid pixel coverage
        retained_covering_images = masked_sentinel2_ratio.filter(coverage_filter)

        # Get the number of images before filtering by valid pixel ratio
        num_images_before = masked_sentinel2.size().getInfo()
        print(f"Number of images before filtering by valid pixel ratio: {num_images_before}")

        # Get the number of images in the final collection after filtering
        num_images_final = retained_covering_images.size().getInfo()
        print(f"Number of images after filtering by valid pixel ratio: {num_images_final}")

        if num_images_final < 10:
            self.pop_aviso("No images found after filtering. Please adjust the threshold ratio.")
            return
        
        if self.remove_cloudy.isChecked():
            self.sentinel2 = retained_covering_images
            
        else:
            # Get the list of image IDs from the retained_covering_images collection
            image_ids = retained_covering_images.aggregate_array('system:index').getInfo()

            # Filter the original sentinel2 collection using the list of image IDs
            filtered_sentinel2 = sentinel2.filter(ee.Filter.inList('system:index', image_ids))

            # Print the number of images in the filtered collection
            num_filtered_images = filtered_sentinel2.size().getInfo()
            print(f"Number of images in the filtered Sentinel-2 collection: {num_filtered_images}")
            self.sentinel2 = filtered_sentinel2

        self.calculate_timeseries()      
    

    def resetting(self):
        self.recorte_datas = None
        self.load_vector_function()
        self.get_dates()
        self.customfilter.setChecked(False)
        self.remove_cloudy.setChecked(False)
        self.filtro1.setChecked(False)
        self.filtro_grau.setCurrentIndex(0)
        self.window_len.setCurrentIndex(0)




    def loadtimeseries_clicked(self):
        ee.Initialize()

        area = self.find_centroid()
        if area >=100:
            self.pop_aviso(f"Area too large ({area:.2f} km²). The limit is 100 km².")
            return
        


        self.resetting()
        QApplication.setOverrideCursor(Qt.WaitCursor)
        aoi = self.aoi
        


        # Definir a coleção de imagens Sentinel-2 com filtragem por porcentagem de nuvens
        sentinel2 = ee.ImageCollection('COPERNICUS/S2_SR_HARMONIZED') \
            .filterDate(self.inicio, self.final) \
            .filterBounds(self.aoi) \
            .filter(ee.Filter.lt('CLOUDY_PIXEL_PERCENTAGE', self.nuvem))
        

        # Step 5: Define Coverage Ratio Function
        # -------------------------------
        aoi_geometry = self.aoi.first().geometry()
        aoi_area = aoi_geometry.area()

        coverage_threshold = self.horizontalSlider_2.value()/100

        def calculate_coverage_ratio(image):
            """
            Calculates the ratio of the AOI area covered by the image.
            
            Args:
                image (ee.Image): The Sentinel-2 image.
            
            Returns:
                ee.Image: The original image with an added 'coverage_ratio' property.
            """
            # Compute the intersection geometry between AOI and image footprint
            intersection = aoi_geometry.intersection(image.geometry(), ee.ErrorMargin(1))
            
            # Calculate the area of the intersection
            intersection_area = intersection.area()
            
            # Calculate the coverage ratio (intersection area / AOI area)
            coverage_ratio = intersection_area.divide(aoi_area)
            
            # Set the coverage ratio as a property of the image
            return image.set('coverage_ratio', coverage_ratio)

        # -------------------------------
        # Step 6: Apply Coverage Ratio Calculation
        # -------------------------------

        # Map the coverage ratio function over the Sentinel-2 collection
        sentinel2_with_ratio = sentinel2.map(calculate_coverage_ratio)

        # -------------------------------
        # Step 7: Filter Based on Coverage Ratio
        # -------------------------------

        # Define a filter to keep images with coverage_ratio >= coverage_threshold
        coverage_filter = ee.Filter.gte('coverage_ratio', coverage_threshold)

        # Apply the filter to get the final collection
        fully_covering_images = sentinel2_with_ratio.filter(coverage_filter)

        # Get the number of images before filtering
        initial_count = sentinel2.size().getInfo()

        # Get the number of images after coverage filtering
        filtered_count = fully_covering_images.size().getInfo()

        print(f"Number of images before coverage filtering: {initial_count}")
        print(f"Number of images with >= {coverage_threshold*100}% AOI coverage: {filtered_count}")

        
        self.sentinel2 = fully_covering_images
        
        self.sentinel2_aux = fully_covering_images

        self.calculate_timeseries()

    def calculate_timeseries(self):
        vegetation_index = self.series_indice.currentText()    

        # Define the vegetation index calculation in a function
        def calculate_index(image):
            if vegetation_index == 'NDVI':
                index_image = image.normalizedDifference(['B8', 'B4']).rename('index')
            elif vegetation_index == 'EVI':
                index_image = image.expression(
                    '2.5 * ((NIR / 10000 - RED / 10000) / (NIR / 10000 + 6 * RED / 10000 - 7.5 * BLUE / 10000 + 1))', {
                        'NIR': image.select('B8'),
                        'RED': image.select('B4'),
                        'BLUE': image.select('B2')
                    }
                ).rename('index')
            elif vegetation_index == 'SAVI':
                L = 0.5
                index_image = image.expression(
                    '(1 + L) * ((NIR / 10000) - (RED / 10000)) / ((NIR / 10000) + (RED / 10000) + L)', {
                        'NIR': image.select('B8'),
                        'RED': image.select('B4'),
                        'L': L
                    }
                ).rename('index')
            elif vegetation_index == 'GCI':
                index_image = image.expression(
                    'NIR / GREEN - 1', {
                        'NIR': image.select('B8'),
                        'GREEN': image.select('B3')
                    }
                ).rename('index')
            elif vegetation_index == 'GNDVI':
                index_image = image.normalizedDifference(['B8', 'B3']).rename('index')
            else:
                raise ValueError(f"Unsupported vegetation index: {vegetation_index}")
            
            # Calculate mean value for the index over AOI
            mean_index = index_image.reduceRegion(
                reducer=ee.Reducer.mean(),
                geometry=self.aoi.geometry(),
                scale=10,
                bestEffort=True
            ).get('index')
            
            return image.set({'date': image.date().format('YYYY-MM-dd'), 'mean_index': mean_index})

        # Map the calculation function over the collection and get results
        result = self.sentinel2.map(calculate_index)
        result = result.filter(ee.Filter.notNull(['mean_index']))

        # Retrieve dates and mean index values separately using aggregate_array
        dates = result.aggregate_array('date').getInfo()
        mean_indices = result.aggregate_array('mean_index').getInfo()

        # Combine the dates and mean indices into a list of dictionaries
        avg_index_values = [{'date': date, 'average_index': index} for date, index in zip(dates, mean_indices)]

        # Convert to DataFrame and group by date
        df = pd.DataFrame(avg_index_values)
        df = df.groupby('date')['average_index'].mean().reset_index()
        print(df)

        # Optional: Smoothing or further processing
        self.df = df.copy()
        self.df_aux = df.copy()
        self.load_dates()
        self.plot_timeseries()

    def clear_all_raster_layers(self):
        # Get the current project instance
        project = QgsProject.instance()

        # Create a copy of the layer list to avoid issues with removing during iteration
        layers_to_remove = list(project.mapLayers().values())  

        # Iterate over the copied list
        for layer in layers_to_remove:
            if layer.type() == QgsMapLayer.RasterLayer and layer.name() != "Google Hybrid":
                layer_name = layer.name()  # Store the layer name before removing it
                project.removeMapLayer(layer.id())  # Use layer.id() for removal
                print(f"Removed raster layer: {layer_name}")
                iface.mapCanvas().refresh()

    def df_ajust(self):
        df = self.df.copy()
        if self.recorte_datas:
            df = df[df['date'].isin(self.recorte_datas)]
            self.df_aux = df.copy()
        print(self.df_aux)

        if self.window_len.count() == 0:
                    self.window_len.clear()
                    self.window_len.addItems(list(map(str, list(range(7, len(df)+1)))))
                    self.window_len.setCurrentIndex(0)

        window_length = int(self.window_len.currentText())
        polyorder = int(self.filtro_grau.currentText().split('%')[0])
        print(f'Window length: {window_length}, Polyorder: {polyorder}')

        if window_length > len(df):
            window_length = len(df)
            self.window_len.setCurrentIndex(len(df) - 5)
            print(f'Window length too large. Using maximum value: {window_length}')

        df['smoothed_index'] = savgol_filter(df['average_index'], window_length=window_length, polyorder=polyorder)
        print(df)

        self.df_aux = df.copy()

    def plot_timeseries(self):
        
        print('plot1 começou, novo')
        self.df_ajust()
        df = self.df_aux

        # Prepare to plot
        myFile = io.StringIO()
        if self.filtro1.isChecked():
            self.fig = go.Figure()
            self.fig.add_trace(go.Scatter(x=df['date'], y=df['average_index'], mode='lines', name=self.series_indice.currentText(), line=dict(color='green')))
            self.fig.add_trace(go.Scatter(x=df['date'], y=df['smoothed_index'], mode='lines', name=self.series_indice.currentText()+' filtered', line=dict(color='purple')))
        else:
            self.fig = go.Figure()
            self.fig.add_trace(go.Scatter(x=df['date'], y=df['average_index'], mode='lines', name=self.series_indice.currentText(), line=dict(color='green')))
       
        self.fig.update_layout(xaxis_title='Date', yaxis_title=self.series_indice.currentText(), title='Time Series - '+self.series_indice.currentText() +' - '+ self.vector_layer_combobox.currentText()
                               +'               Image count: '+ str(len(df)))
    
        self.fig.update_traces(hovertemplate='date = %{x|%Y-%m-%d}<br>average_ndvi = %{y:.2f}<extra></extra>')
        
        # Configurations for the Plotly plot
        config = {
            'displaylogo': False,
            'modeBarButtonsToRemove': [
                "toImage", "sendDataToCloud", "zoom2d", "pan2d", "select2d",
                "lasso2d", "zoomIn2d", "zoomOut2d", "autoScale2d", "resetScale2d",
                "hoverClosestCartesian", "hoverCompareCartesian", "zoom3d",
                "pan3d", "orbitRotation", "tableRotation", "resetCameraLastSave",
                "resetCameraDefault3d", "hoverClosest3d", "zoomInGeo", 
                "zoomOutGeo", "resetGeo", "hoverClosestGeo", "hoverClosestGl2d",
                "hoverClosestPie", "toggleHover", "toggleSpikelines", "resetViews"
            ]
        }

        if isinstance(self.df_nasa, pd.DataFrame):
            # Add bar plot (set below the line explicitly)
            self.fig.add_trace(go.Bar(
                x=self.df_nasa.index, 
                y=self.df_nasa['PRECTOTCORR'], 
                name='Monthly Precipitation', 
                yaxis='y2', 
                marker_color='blue',
                opacity=0.4
            ))

            # Ensure correct layout and layering
            self.fig.update_layout(
                yaxis=dict(
                    title=self.series_indice.currentText(),
                ),
                yaxis2=dict(
                    title='Precipitation (mm)',
                    overlaying='y',
                    side='right',
                ),
                xaxis=dict(title='Date'),
            )

        
        # Update layout and render the plot
        self.fig.write_html(myFile, config=config)
        html = myFile.getvalue()  
        self.webView.setHtml(html)
        print('ok plot1')

        self.tabWidget.setCurrentIndex(3)
        self.showNormal()
        QApplication.restoreOverrideCursor()

    def open_browser(self):
        self.fig.show()

    def load_dates(self):
        datas = self.df.date.unique().astype(str).tolist()
        self.dataunica.clear()
        self.dataunica.addItems(datas)
        self.dataunica.setCurrentIndex(self.dataunica.count() - 1)

    def load_raster_layer_colorful(self, raster_file_path, layer_name, metrica=None):
        print(f"Loading raster layer color: {metrica}")

        # Load the raster layer
        raster_layer = QgsRasterLayer(raster_file_path, layer_name)
        if not raster_layer.isValid():
            print("Failed to load raster layer!")
        else:
            QgsProject.instance().addMapLayer(raster_layer, False)
            root = QgsProject.instance().layerTreeRoot()
            root.insertChildNode(0, QgsLayerTreeLayer(raster_layer))
            print("Raster layer loaded successfully!")

            # Create a color ramp shader
            color_ramp_shader = QgsColorRampShader()
            color_ramp_shader.setColorRampType(QgsColorRampShader.Interpolated)

            # Load the predefined color ramp (e.g., RdYlGn) from the QGIS style manager
            style = QgsStyle().defaultStyle()
            color_ramp = style.colorRamp('RdYlGn')

            # Check if the color ramp is successfully loaded
            if color_ramp:
                # Define the number of color stops
                num_stops = 5
                min_val = raster_layer.dataProvider().bandStatistics(1).minimumValue
                max_val = raster_layer.dataProvider().bandStatistics(1).maximumValue
                step = (max_val - min_val) / (num_stops - 1)

                # Create color ramp items by interpolating the color ramp
                color_ramp_items = []
                for i in range(num_stops):
                    value = min_val + i * step
                    color = color_ramp.color(i / (num_stops - 1))  # Interpolates color along the ramp
                    color_ramp_items.append(QgsColorRampShader.ColorRampItem(value, color))

                # Set the color ramp items to the color ramp shader
                color_ramp_shader.setColorRampItemList(color_ramp_items)
            else:
                print("Color ramp 'RdYlGn' not found in the QGIS style library.")

            # Create a raster shader and set it to use the color ramp shader
            raster_shader = QgsRasterShader()
            raster_shader.setRasterShaderFunction(color_ramp_shader)

            # Apply the raster shader to the raster layer renderer
            renderer = QgsSingleBandPseudoColorRenderer(raster_layer.dataProvider(), 1, raster_shader)
            raster_layer.setRenderer(renderer)

            # Refresh the layer to update the visualization
            raster_layer.triggerRepaint()

        if metrica == 'NDVI':
            # Clone the current renderer
            newrend = raster_layer.renderer().clone()

            # Set the classification range (min and max values)
            # newrend.setClassificationMin(min_val)
            # newrend.setClassificationMax(max_val)
            newrend.setClassificationMin(0)
            newrend.setClassificationMax(1)

            # Apply the new renderer to the layer
            raster_layer.setRenderer(newrend)
            # Refresh the map canvas to reflect the changes
            iface.mapCanvas().refresh()
        else:
            # Clone the current renderer
            newrend = raster_layer.renderer().clone()

            # Set the classification range (min and max values)
            newrend.setClassificationMin(min_val)
            newrend.setClassificationMax(max_val)
            # newrend.setClassificationMin(0)
            # newrend.setClassificationMax(1)

            # Apply the new renderer to the layer
            raster_layer.setRenderer(newrend)
            # Refresh the map canvas to reflect the changes
            iface.mapCanvas().refresh()

        QApplication.restoreOverrideCursor()